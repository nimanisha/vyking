# DevOps Practical Task - Solution (Local k3d + Terraform + Argo CD + Helm)

## What is included
- `cluster/create-cluster.sh` - creates a k3d cluster (1 server, 2 agents) and a local registry.
- `components/backend-app/` - minimal Go backend + Dockerfile (writes/reads to MySQL).
- `applications/` - single Helm chart that deploys frontend (nginx) and backend (your built image).
- `infrastructure/` - namespace, Bitnami MySQL values, backup PVC, backup CronJob, and a Secret manifest.
- `terraform/` - Terraform to install Argo CD (Helm) and create two Argo CD `Application` resources that point to `infrastructure/` and `applications/`.

## Quick start (full steps)
1. Prereqs: Docker, k3d, kubectl, terraform, helm (optional), go (to build backend image).
2. Clone this repo (or unzip the provided archive).
3. Create the cluster:
   ```bash
   ./cluster/create-cluster.sh
   ```
4. Build and push the backend image to the local registry:
   ```bash
   cd components/backend-app
   docker build -t localhost:5000/backend:latest .
   docker push localhost:5000/backend:latest
   ```
   (k3d is configured to use the registry created by the script)

5. Initialize Terraform and apply (set TF_VAR_repo_url to the URL where the repo will be hosted; if you test locally you can set it to your local filesystem git server or a public repo):
   ```bash
   cd terraform
   export TF_VAR_repo_url="https://github.com/nimanisha/vyking.git"   
   terraform init

   terraform apply -target=null_resource.helm_repo_add -target=time_sleep.wait_for_repo

   terraform apply -target=helm_release.argocd

kubectl get crd | findstr argoproj

   terraform apply
   ```

6. Verify Argo CD:
   ```bash
   kubectl -n argocd get pods
   # port-forward the server:
   kubectl -n argocd port-forward svc/argocd-argocd-server 8080:80
   # initial password:
   kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d
   # open http://localhost:8080
   ```

7. Argo CD `infra` application will deploy:
   - `infra` namespace
   - Bitnami MySQL (using `infrastructure/mysql-values.yaml`)
   - Secret `mysql-credentials` (we include `infrastructure/secret-mysql.yaml` as an example to use if you don't want chart-generated secrets)
   - PVC `mysql-backup-pvc`
   - CronJob `mysql-backup` which runs every 5 minutes to create mysqldump files into the backup PVC.

8. Argo CD `applications` will deploy:
   - Helm chart from `applications/` which creates frontend and backend deployments and services.
   - The backend reads MySQL credentials from the Kubernetes `Secret` named `mysql-credentials` in `infra` namespace. The Helm chart references that secret (if you want the secret in `default` namespace, adjust accordingly).

9. Verify backups:
   ```bash
   kubectl -n infra get cronjob
   # find a recent job pod name under jobs
   kubectl -n infra get pods -l job-name=$(kubectl -n infra get jobs --sort-by=.metadata.creationTimestamp -o=jsonpath='{.items[-1].metadata.name}' )
   # or simply exec into any pod that mounts the PVC (create a debug pod) and list /backups
   kubectl -n infra run --rm -it --restart=Never debug --image=alpine -- sh -c "apk add --no-cache bash; sleep 1d"
   # In another shell: kubectl -n infra exec -it debug -- ls -la /backups
   ```

10. Access frontend:
   ```bash
   kubectl port-forward svc/<release-name>-frontend 8081:80
   curl http://localhost:8081
   ```
   Replace `<release-name>` with the release name you choose when installing the Helm chart via Argo CD (by default Argo CD will use the Application name or repository Helm release config).

11. Cleanup:
   ```bash
   cd terraform
   terraform destroy -auto-approve
   # then:
   k3d cluster delete gitops-demo
   k3d registry delete registry.localhost
   ```

## Notes about Secrets and Database
- `infrastructure/secret-mysql.yaml` is a sample Kubernetes Secret manifest containing `user` and `password`. The Bitnami chart can create its own credentials if you set `auth.*` values (we included `mysql-values.yaml` which sets `rootPassword` and `password`).
- The backup CronJob reads credentials from the `mysql-credentials` secret (namespace `infra`).
- For production, do NOT store secrets in plaintext in git. Use sealed-secrets, SOPS, HashiCorp Vault, or external secret controllers.

## If you want me to:
- Replace the Go backend with a prebuilt public image (so you don't have to build locally).
- Render a complete `terraform.tfvars` and a sample GitHub repo layout for immediate `repo_url` usage.
- Add autogenerated Argo CD `Application` manifests with exact namespace interpolation.
Tell me which and I'll update the archive.
